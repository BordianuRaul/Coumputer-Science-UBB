     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ; Given the byte A and the word B, compute the doubleword C as follows:
    14                                      
    15 00000000 D3                          a db 11010011b
    16 00000001 276E                        b dw 0110111000100111b
    17 00000003 00000000                    c dd 0
    18                                  
    19                                  ; our code starts here
    20                                  segment code use32 class=code
    21                                      start:
    22                                          
    23                                          ; the bits 0-7 of C have the value 1
    24                                          ; the bits 8-11 of C are the same as the bits 4-7 of A
    25                                          ; the bits 12-19 are the same as the bits 2-9 of B
    26                                          ; the bits 20-23 are the same as the bits 0-3 of A
    27                                          ; the bits 24-31 are the same as the high byte of B
    28                                          
    29                                          
    30                                          ; the bits 0-7 of C have the value 1
    31                                          ; We will compute the final result in EBX
    32                                          
    33 00000000 BBFF000000                      mov EBX, 00000000000000000000000011111111b ; We force bits 0-7 to be equal to 1
    34                                          
    35                                          ; the bits 8-11 of C are the same as the bits 4-7 of A
    36                                          
    37                                          ; first we need to convert the value of a which is a byte to a doubleword
    38 00000005 A0[00000000]                    mov AL, [a] ; AL = a
    39                                          
    40 0000000A B400                            mov AH, 0 ; We convert AL to AX
    41                                          
    42 0000000C 6625F000                        and AX, 0000000011110000b ; we isolate the bits 4-7 from a
    43                                          
    44 00000010 B104                            mov CL, 4
    45                                          
    46 00000012 66D3C0                          rol AX, CL ; we rotate 4 positions to the left, AX = 0000 1101 0000 0000b = 3328
    47                                          
    48 00000015 66BA0000                        mov DX, 0 ; convert AX to DX:AX
    49                                          
    50 00000019 6652                            push DX
    51                                          
    52 0000001B 6650                            push AX
    53                                          
    54 0000001D 58                              pop EAX
    55                                          
    56 0000001E 09C3                            or EBX, EAX ; we put the bits into the result EBX = 0000 0000 0000 0000 0000 1101 1111 1111b = 3583
    57                                          
    58                                          
    59                                          ; the bits 12-19 are the same as the bits 2-9 of B
    60                                          
    61 00000020 66A1[01000000]                  mov AX, [b] ; AX = b = 0110111000100111b = 28199
    62                                          
    63 00000026 6625FC03                        and AX, 0000001111111100b ; we isolate the bits 2-9 of B
    64                                          
    65 0000002A 66BA0000                        mov DX, 0 ; convert AX to DX:AX
    66                                          
    67 0000002E 6652                            push DX
    68                                          
    69 00000030 6650                            push AX
    70                                          
    71 00000032 58                              pop EAX ;  we convert DX:AX to EAX
    72                                          
    73 00000033 B10A                            mov CL, 10
    74                                          
    75 00000035 D3C0                            rol EAX, cl ; we rotate 10 positions to the left
    76                                          
    77 00000037 09C3                            or EBX, EAX ; we put the bits into the result, EBX = 0000 0000 0000 1000 1001 1101 1111 1111b = 564735
    78                                          
    79                                          ; the bits 20-23 are the same as the bits 0-3 of A
    80                                          
    81 00000039 A0[00000000]                    mov AL, [a] ; AL = A
    82                                          
    83 0000003E 240F                            and AL, 00001111b ;  we isolate the bits 0-3 of A
    84                                          
    85 00000040 B400                            mov AH, 0 ; convert AL to AX
    86                                          
    87 00000042 66BA0000                        mov DX, 0 ; convert AX to DX:AX
    88                                          
    89 00000046 6652                            push DX
    90                                          
    91 00000048 6650                            push AX
    92                                          
    93 0000004A 58                              pop EAX ; convert DX:AX to EAX
    94                                          
    95 0000004B B114                            mov CL, 20
    96                                          
    97 0000004D D3C0                            rol EAX, cl ; rotate 20 positions to left
    98                                          
    99 0000004F 09C3                            or EBX, EAX ; we put the bits into the result, EBX = 0000 0000 0011 1000 1001 1101 1111 1111b = 3710463
   100                                          
   101                                          ; the bits 24-31 are the same as the high byte of B
   102                                          
   103 00000051 66A1[01000000]                  mov AX, [b] ; AX = B
   104                                          
   105 00000057 662500FF                        and AX, 1111111100000000b ; we isolate the high byte of B
   106                                          
   107 0000005B 66BA0000                        mov DX, 0 ; convert AX to DX:AX
   108                                          
   109 0000005F 6652                            push DX
   110                                          
   111 00000061 6650                            push AX
   112                                          
   113 00000063 58                              pop EAX ; convert DX:AX to EAX
   114                                          
   115 00000064 B110                            mov CL, 16
   116                                          
   117 00000066 D3C0                            rol EAX, CL ; we rotate 20 positions to left
   118                                          
   119 00000068 09C3                            or EBX, EAX ; we put the bits into the resul, EBX = 0110 1110 0011 1000 1001 1101 1111 1111b = 1849204223
   120                                          
   121                                          ; exit(0)
   122 0000006A 6A00                            push    dword 0      ; push the parameter for exit onto the stack
   123 0000006C FF15[00000000]                  call    [exit]       ; call exit to terminate the program
